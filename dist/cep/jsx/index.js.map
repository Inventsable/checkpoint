{"version":3,"file":"index.js","sources":["../../../cep.config.ts","../../../src/shared/shared.ts","../../../src/jsx/ilst/ilst.ts","../../../src/jsx/index.ts"],"sourcesContent":["import { CEP_Config } from \"vite-cep-plugin\";\nimport { version } from \"./package.json\";\n\nconst config: CEP_Config = {\n  version,\n  id: \"com.checkpoint.cep\",\n  displayName: \"Checkpoint\",\n  symlink: \"local\",\n  port: 3000,\n  servePort: 5000,\n  startingDebugPort: 8860,\n  extensionManifestVersion: 6.0,\n  requiredRuntimeVersion: 9.0,\n  hosts: [{ name: \"ILST\", version: \"[0.0,99.9]\" }],\n  type: \"Panel\",\n  iconDarkNormal: \"./src/assets/light-icon.png\",\n  iconNormal: \"./src/assets/dark-icon.png\",\n  iconDarkNormalRollOver: \"./src/assets/light-icon.png\",\n  iconNormalRollOver: \"./src/assets/dark-icon.png\",\n  parameters: [\"--v=0\", \"--enable-nodejs\", \"--mixed-context\"],\n  width: 500,\n  height: 550,\n  panels: [\n    {\n      mainPath: \"./main/index.html\",\n      name: \"main\",\n      panelDisplayName: \"Checkpoint\",\n      autoVisible: true,\n      width: 300,\n      height: 500,\n      minWidth: 40,\n      minHeight: 370,\n      maxWidth: 350,\n      maxHeight: 700,\n    },\n    {\n      mainPath: \"./main/index.html\",\n      name: \"settings\",\n      autoVisible: false,\n      type: \"ModalDialog\",\n      width: 800,\n      height: 650,\n      minHeight: 600,\n      minWidth: 600,\n      maxHeight: 1200,\n      maxWidth: 1200,\n      startOnEvents: [],\n    },\n  ],\n  build: {\n    jsxBin: \"off\",\n    sourceMap: true,\n  },\n  zxp: {\n    country: \"US\",\n    province: \"CA\",\n    org: \"MyCompany\",\n    password: \"mypassword\",\n    tsa: \"http://timestamp.digicert.com/\",\n    sourceMap: false,\n    jsxBin: \"off\",\n  },\n  installModules: [\"showdown\"],\n  copyAssets: [],\n  copyZipAssets: [],\n};\nexport default config;\n","import config from \"../../cep.config\";\r\nexport const ns = config.id;\r\n\r\nexport interface cmykColor {\r\n  cyan: number;\r\n  magenta: number;\r\n  yellow: number;\r\n  black: number;\r\n  typename?: string;\r\n}\r\nexport interface rgbColor {\r\n  red: number;\r\n  green: number;\r\n  blue: number;\r\n  typename?: string;\r\n}\r\nexport interface hsbColor {\r\n  hue: number;\r\n  saturation: number;\r\n  brightness: number;\r\n  typename?: string;\r\n}\r\n\r\nexport interface ColorPackage {\r\n  RGB: rgbColor;\r\n  HSB: hsbColor;\r\n  CMYK: cmykColor;\r\n  hex: string;\r\n  model: string;\r\n  name?: string;\r\n}\r\n\r\nexport type ColorValue = rgbColor | cmykColor | hsbColor;\r\n\r\nexport interface DocumentDiagonostic {\r\n  paths: {\r\n    count: number;\r\n    anchors: number;\r\n  };\r\n  layerCount: number;\r\n  colorModel: string;\r\n  name: string;\r\n  path: string;\r\n}\r\n\r\ninterface StyleSetting {\r\n  width: number;\r\n  size: number;\r\n  color: ColorValue | ColorPackage;\r\n  filled: boolean;\r\n}\r\n\r\nexport interface Config {\r\n  anchor: {\r\n    style: StyleSetting;\r\n    label: string;\r\n  };\r\n  handle: {\r\n    style: StyleSetting;\r\n    label: string;\r\n  };\r\n  stick: {\r\n    style: {\r\n      width: number;\r\n    };\r\n    label: string;\r\n  };\r\n  outline: {\r\n    style: {\r\n      width: number;\r\n      color: ColorValue | ColorPackage;\r\n    };\r\n  };\r\n  options: {\r\n    useLayerLabelColor: boolean;\r\n    overrideComplex: boolean;\r\n    forceOpacity: boolean;\r\n    renameGenericPaths: boolean;\r\n    generateIds: boolean;\r\n    groupRelated: boolean;\r\n    scaleFactor: number;\r\n    ignoreBackgrounds: boolean;\r\n    ignoreHidden: boolean;\r\n    ignoreLocked: boolean;\r\n    warnForComplexArt: boolean;\r\n    mergeClippingMasks: boolean;\r\n    createAsCopy: boolean;\r\n    copySuffix: string;\r\n    ignoreCMYKColorAlerts: boolean;\r\n    displayBG: {\r\n      include: boolean;\r\n      color: ColorValue;\r\n    };\r\n    chunks: {\r\n      size: number;\r\n      enabled: boolean;\r\n      maxAnchors: number;\r\n    };\r\n    suffixes: {\r\n      handle: string;\r\n      anchor: string;\r\n      stick: string;\r\n      outline: string;\r\n      parent: string;\r\n    };\r\n  };\r\n}\r\n","import type {\r\n  ColorPackage,\r\n  ColorValue,\r\n  Config,\r\n  DocumentDiagonostic,\r\n  cmykColor,\r\n  rgbColor,\r\n} from \"../../shared/shared\";\r\n\r\ninterface DialogOptions {\r\n  title: string;\r\n  header: string;\r\n  body: string;\r\n}\r\ninterface PathPoint {\r\n  anchor: number[];\r\n  leftDirection: number[];\r\n  parent: any;\r\n  pointType: any;\r\n  selected: boolean;\r\n  rightDirection: number[];\r\n  typename: string;\r\n  remove: () => void;\r\n}\r\n\r\nconst DEBUG = false;\r\n\r\nexport const displayWarning = (options: string) => {\r\n  const dialogOpts = JSON.parse(options) as DialogOptions;\r\n  const result = scriptConfirmation(dialogOpts);\r\n  return result;\r\n};\r\n\r\n// Thanks Stephen\r\n// https://github.com/MarshySwamp/ScriptUI-Confirm-Window\r\nexport const scriptConfirmation = (options: DialogOptions) => {\r\n  let confirmationTitle = options.title,\r\n    confirmationString2 = options.body;\r\n  try {\r\n    let confirmationWindow = new Window(\"dialog\");\r\n    confirmationWindow.text = confirmationTitle;\r\n    confirmationWindow.preferredSize.width = 400;\r\n    confirmationWindow.preferredSize.height = 60;\r\n    confirmationWindow.orientation = \"column\";\r\n    // @ts-ignore\r\n    confirmationWindow.alignChildren = [\"left\", \"top\"];\r\n    confirmationWindow.spacing = 15;\r\n    confirmationWindow.margins = 20;\r\n    let textGroup = confirmationWindow.add(\"group\", undefined, {\r\n      name: \"textGroup\",\r\n    });\r\n    textGroup.preferredSize.width = 400;\r\n    textGroup.orientation = \"column\";\r\n    textGroup.alignChildren = [\"left\", \"center\"];\r\n    textGroup.spacing = 5;\r\n    textGroup.margins = 0;\r\n    let confirmationText2 = textGroup.add(\"statictext\", undefined, undefined, {\r\n      name: \"confirmationText2\",\r\n      multiline: true,\r\n    });\r\n    confirmationText2.text = confirmationString2;\r\n    // @ts-ignore\r\n    confirmationText2.graphics.font = \"dialog:13\";\r\n    confirmationText2.alignment = [\"left\", \"center\"];\r\n    confirmationText2.preferredSize.width = 400;\r\n    let buttonGroup = confirmationWindow.add(\"group\", undefined, {\r\n      name: \"buttonGroup\",\r\n    });\r\n    buttonGroup.orientation = \"row\";\r\n    buttonGroup.alignChildren = [\"right\", \"top\"];\r\n    buttonGroup.spacing = 0;\r\n    buttonGroup.margins = 10;\r\n    buttonGroup.preferredSize.width = 400;\r\n    let cancelButton = buttonGroup.add(\"button\", undefined, undefined, {\r\n      name: \"cancelButton\",\r\n    });\r\n    cancelButton.text = \"CANCEL\";\r\n    cancelButton.justify = \"right\";\r\n    let okButton = buttonGroup.add(\"button\", undefined, undefined, {\r\n      name: \"okButton\",\r\n    });\r\n    okButton.text = \"OK\";\r\n    okButton.justify = \"right\";\r\n    return confirmationWindow.show() === 1;\r\n  } catch (err) {\r\n    return false;\r\n  }\r\n};\r\n\r\nexport const newRGB = (color: rgbColor): rgbColor => {\r\n  const temp = new RGBColor() as rgbColor;\r\n  temp.red = color.red;\r\n  temp.green = color.green;\r\n  temp.blue = color.blue;\r\n  return temp;\r\n};\r\nexport const newCMYK = (color: cmykColor): cmykColor => {\r\n  const temp = new CMYKColor() as cmykColor;\r\n  temp.cyan = color.cyan;\r\n  temp.magenta = color.magenta;\r\n  temp.yellow = color.yellow;\r\n  temp.black = color.black;\r\n  return temp;\r\n};\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\r\n// @ts-ignore\r\nif (!Array.isArray) {\r\n  // @ts-ignore\r\n  Array.isArray = function (arg) {\r\n    return Object.prototype.toString.call(arg) === \"[object Array]\";\r\n  };\r\n}\r\n// @ts-ignore\r\nArray.prototype.map = function (callback) {\r\n  let mappedParam = [];\r\n  for (let i = 0; i < this.length; i++)\r\n    mappedParam.push(callback(this[i], i, this));\r\n  return mappedParam;\r\n};\r\n// @ts-ignore\r\nArray.prototype.filter = function (callback) {\r\n  let filtered = [];\r\n  for (let i = 0; i < this.length; i++)\r\n    if (callback(this[i], i, this)) filtered.push(this[i]);\r\n  return filtered;\r\n};\r\n// @ts-ignore\r\nArray.prototype.reduce = function (fn, initial) {\r\n  let values = this;\r\n  // @ts-ignore\r\n  values.forEach(function (item: any) {\r\n    initial = initial !== undefined ? fn(initial, item) : item;\r\n  });\r\n  return initial;\r\n};\r\n// @ts-ignore\r\nArray.prototype.forEach = function (callback) {\r\n  for (let i = 0; i < this.length; i++) callback(this[i], i, this);\r\n};\r\n// @ts-ignore\r\nArray.prototype.every = function (callback) {\r\n  let count = 0;\r\n  for (let i = 0; i < this.length; i++) if (callback(this[i], i, this)) count++;\r\n  return count == this.length;\r\n};\r\n// @ts-ignore\r\nArray.prototype.flat = function () {\r\n  // @ts-ignore\r\n  function flattenArrayOfArrays(a, r) {\r\n    if (!r) r = [];\r\n    for (let i = 0; i < a.length; i++)\r\n      // @ts-ignore\r\n      if (Array.isArray(a[i])) r.concat(flattenArrayOfArrays(a[i], r));\r\n      else r.push(a[i]);\r\n    return r;\r\n  }\r\n  // @ts-ignore\r\n  return flattenArrayOfArrays(this);\r\n};\r\n\r\n// @ts-ignore\r\nArray.prototype.some = function (callback) {\r\n  for (let i = 0; i < this.length; i++)\r\n    if (callback(this[i], i, this)) return true;\r\n  return false;\r\n};\r\n\r\n// @ts-ignore\r\nfunction get(type, parent, deep) {\r\n  if (arguments.length == 1 || !parent) {\r\n    parent = app.activeDocument;\r\n    deep = true;\r\n  }\r\n  let result = [];\r\n  if (!parent[type]) return [];\r\n  for (let i = 0; i < parent[type].length; i++) {\r\n    result.push(parent[type][i]);\r\n    if (parent[type][i][type] && deep)\r\n      // @ts-ignore\r\n      result = [].concat(result, get(type, parent[type][i], deep));\r\n  }\r\n  return result;\r\n}\r\n\r\nexport const getColorFromPicker = (previous: string) => {\r\n  const input: ColorValue | null = previous\r\n    ? (JSON.parse(previous) as ColorValue)\r\n    : null;\r\n  const isRGB = app.activeDocument.documentColorSpace == DocumentColorSpace.RGB;\r\n  let val = input;\r\n  if (!val)\r\n    val = isRGB\r\n      ? {\r\n          red: 50,\r\n          green: 50,\r\n          blue: 50,\r\n        }\r\n      : {\r\n          cyan: 50,\r\n          magenta: 50,\r\n          yellow: 50,\r\n          black: 50,\r\n        };\r\n  const colorValue = isRGB ? new RGBColor() : new CMYKColor();\r\n  // @ts-ignore\r\n  for (let key in val) colorValue[key] = val[key];\r\n  const newResult = app.showColorPicker(colorValue);\r\n  if (newResult) {\r\n    // @ts-ignore\r\n    for (let key in newResult) newResult[key] = Math.floor(newResult[key]);\r\n    return JSON.stringify(newResult);\r\n  } else return null;\r\n};\r\n\r\nexport const startOutliner = (data: string): string | boolean => {\r\n  const asChunks = false;\r\n  const config = JSON.parse(data) as Config;\r\n  // \"Target layer cannot be modified\" bug in scripting if a user has a locked\r\n  // top layer. Really odd, I've literally never seen that before\r\n  const topLayerLock = app.activeDocument.layers[0].locked;\r\n  app.activeDocument.layers[0].locked = false;\r\n  if (asChunks) {\r\n    alert(\"Not currently supported\");\r\n    return false;\r\n  } else {\r\n    const list = scanCurrentPageItems(config);\r\n    convertListToOutlines(config, list);\r\n    sortLayerContents();\r\n  }\r\n  app.activeDocument.layers[0].locked = topLayerLock;\r\n  return \"HELLO\";\r\n};\r\n\r\nexport const overrideActiveLayerIfLocked = (): void => {\r\n  const activeIsLocked = app.activeDocument.activeLayer.locked,\r\n    // @ts-ignore\r\n    freeLayers = get(\"layers\").filter((layer) => !layer.locked);\r\n  if (activeIsLocked) app.activeDocument.activeLayer.locked = false;\r\n  if (activeIsLocked && freeLayers.length) {\r\n    app.activeDocument.activeLayer = freeLayers[0];\r\n  } else if (activeIsLocked && !freeLayers.length) {\r\n    alert(\"Cannot run when all layers are locked\");\r\n  }\r\n};\r\n\r\nexport const runDiagnostic = (): string => {\r\n  overrideActiveLayerIfLocked();\r\n  const dia = {\r\n    paths: {\r\n      count: app.activeDocument.pathItems.length,\r\n      // @ts-ignore\r\n      anchors: get(\"pathItems\")\r\n        // @ts-ignore\r\n        .map((i) => i.pathPoints.length)\r\n        .reduce((sum: number, a: number) => sum + a, 0),\r\n    },\r\n    layerCount: app.activeDocument.layers.length,\r\n    colorModel: /RGB/.test(app.activeDocument.documentColorSpace + \"\")\r\n      ? \"RGB\"\r\n      : \"CMYK\",\r\n    name: app.activeDocument.name,\r\n    // @ts-ignore\r\n    path: File(app.activeDocument.fullName).parent.fsName,\r\n  } as DocumentDiagonostic;\r\n  return JSON.stringify(dia);\r\n};\r\n\r\nexport const generateColor = (color: ColorPackage) => {\r\n  return color.model == \"RGB\" ? newRGB(color.RGB) : newCMYK(color.CMYK);\r\n};\r\n\r\nexport const scanCurrentPageItems = (config: Config): any[] => {\r\n  let list = [];\r\n  if (!config.options.overrideComplex) {\r\n    if (config.options.mergeClippingMasks) mergeClippingPaths();\r\n    // @ts-ignore\r\n    return filteredList(config, get(\"pathItems\"));\r\n  } else {\r\n    return cloneAllPathItems(config);\r\n  }\r\n};\r\n\r\nexport const filteredList = (config: Config, list: any[]): any[] => {\r\n  // @ts-ignore\r\n  return list.filter((i) => {\r\n    // TODO - Items matching color of designated background should be filtered\r\n    const isBackgroundState = pathIsEquivalentToBackground(config, i);\r\n    let didPassVisible = !config.options.ignoreHidden\r\n      ? !getAncestryChain(i, \"visible\", true, [i.hidden])\r\n          // @ts-ignore\r\n          .some((i) => !!i)\r\n      : false;\r\n    let didPassLock = !config.options.ignoreLocked\r\n      ? !getAncestryChain(i, \"locked\", false, [i.locked])\r\n          // @ts-ignore\r\n          .some((i) => !!i)\r\n      : false;\r\n    return didPassVisible && didPassLock && /^pathItem$/i.test(i.typename);\r\n  });\r\n};\r\n\r\nexport const getAncestryChain = (\r\n  item: any,\r\n  prop: string,\r\n  toggled: boolean,\r\n  chain: any[]\r\n): any => {\r\n  if (item.parent && !/document/i.test(item.parent.typename)) {\r\n    let needSwitch = prop == \"visible\" && item.parent.uuid;\r\n    let realProp = needSwitch ? \"hidden\" : prop;\r\n    let realToggled = needSwitch ? !toggled : toggled;\r\n    chain = [].concat(\r\n      // @ts-ignore\r\n      chain,\r\n      realToggled ? !item.parent[realProp] : item.parent[realProp]\r\n    );\r\n    return getAncestryChain(item.parent, prop, toggled, chain);\r\n  } else return chain;\r\n};\r\n\r\nexport const pathIsEquivalentToBackground = (\r\n  config: Config,\r\n  path: any\r\n): boolean => {\r\n  // Not yet implemented\r\n  return false;\r\n};\r\n\r\nexport const convertListToOutlines = (config: Config, list: any[]) => {\r\n  for (let i = list.length - 1; i >= 0; i--) {\r\n    let item = list[i];\r\n    if (DEBUG) {\r\n      alert(item);\r\n    }\r\n    const parentage = item.name || item.parent.name || item.layer.name;\r\n    item.name = config.options.renameGenericPaths\r\n      ? // @ts-ignore\r\n        rollName(config, parentage, item, item.layer)\r\n      : parentage;\r\n    if (item.stroked || item.filled) {\r\n      replaceAppearance(config, item);\r\n      let parentgroup = config.options.groupRelated\r\n        ? app.activeDocument.groupItems.add()\r\n        : null;\r\n      if (config.options.groupRelated && parentgroup && !item.layer.locked) {\r\n        if (!parentgroup.locked) {\r\n          parentgroup.name = item.name + config.options.suffixes.parent;\r\n          // @ts-ignore\r\n          parentgroup.move(item.layer, ElementPlacement.PLACEATBEGINNING);\r\n        }\r\n      }\r\n      if (item.pathPoints && item.pathPoints.length)\r\n        for (let p = 0; p < item.pathPoints.length; p++) {\r\n          let point = item.pathPoints[p];\r\n          let pointName = item.name + \"[\" + p + \"]\";\r\n          let group = config.options.groupRelated\r\n            ? // @ts-ignore\r\n              parentgroup.groupItems.add()\r\n            : null;\r\n          // @ts-ignore\r\n          if (config.options.groupRelated) group.name = pointName;\r\n          drawAnchor(config, point, item.layer, pointName, group);\r\n          drawHandle(config, point, \"left\", item.layer, pointName, group);\r\n          drawHandle(config, point, \"right\", item.layer, pointName, group);\r\n          item.opacity = config.options.forceOpacity ? 100.0 : item.opacity;\r\n        }\r\n    }\r\n  }\r\n};\r\n\r\nexport const drawAnchor = (\r\n  config: Config,\r\n  point: PathPoint,\r\n  layer: any,\r\n  name: string,\r\n  group: any\r\n) => {\r\n  const root = config.options.groupRelated ? group : app.activeDocument;\r\n  let anchor = root.pathItems.rectangle(\r\n    point.anchor[1] + config.anchor.style.size / 2,\r\n    point.anchor[0] - config.anchor.style.size / 2,\r\n    config.anchor.style.size,\r\n    config.anchor.style.size\r\n  );\r\n  anchor.name = name + config.anchor.label;\r\n  if (!config.options.groupRelated && !layer.locked)\r\n    // @ts-ignore\r\n    anchor.move(layer, ElementPlacement.PLACEATBEGINNING);\r\n  setAnchorAppearance(config, anchor, false, layer);\r\n  return [anchor];\r\n};\r\n\r\nexport const drawHandle = (\r\n  config: Config,\r\n  point: PathPoint,\r\n  direction: string,\r\n  layer: any,\r\n  name: string,\r\n  group: any\r\n) => {\r\n  if (\r\n    Number(point.anchor[0]) !==\r\n      Number(point[(direction + \"Direction\") as keyof PathPoint][0]) ||\r\n    Number(point.anchor[1]) !==\r\n      Number(point[(direction + \"Direction\") as keyof PathPoint][1])\r\n  ) {\r\n    let stick = config.options.groupRelated\r\n      ? group.pathItems.add()\r\n      : app.activeDocument.pathItems.add();\r\n    stick.setEntirePath([\r\n      point.anchor,\r\n      point[(direction + \"Direction\") as keyof PathPoint],\r\n    ]);\r\n    if (!config.options.groupRelated && !layer.locked)\r\n      // @ts-ignore\r\n      stick.move(layer, ElementPlacement.PLACEATBEGINNING);\r\n    stick.name =\r\n      name + \"_\" + direction.charAt(0).toUpperCase() + config.stick.label;\r\n\r\n    setAnchorAppearance(config, stick, true, layer);\r\n\r\n    const root = config.options.groupRelated ? group : app.activeDocument;\r\n\r\n    let handle = root.pathItems.ellipse(\r\n      point[(direction + \"Direction\") as keyof PathPoint][1] +\r\n        config.handle.style.size / 2,\r\n      point[(direction + \"Direction\") as keyof PathPoint][0] -\r\n        config.handle.style.size / 2,\r\n      config.handle.style.size,\r\n      config.handle.style.size\r\n    );\r\n    if (!config.options.groupRelated && !layer.locked)\r\n      // @ts-ignore\r\n      handle.move(layer, ElementPlacement.PLACEATBEGINNING);\r\n    handle.stroked = false;\r\n    handle.filled = true;\r\n    handle.name =\r\n      name + \"_\" + direction.charAt(0).toUpperCase() + config.handle.label;\r\n    handle.fillColor = config.options.useLayerLabelColor\r\n      ? layer.color\r\n      : generateColor(config.handle.style.color as ColorPackage);\r\n    return [stick, handle];\r\n  }\r\n};\r\n\r\nexport const setAnchorAppearance = (\r\n  config: Config,\r\n  item: any,\r\n  isHandle: boolean,\r\n  layer: any\r\n): void => {\r\n  let realColor = config.options.useLayerLabelColor\r\n    ? layer.color\r\n    : generateColor(config.anchor.style.color as ColorPackage);\r\n  if (!isHandle) {\r\n    item.filled = config.anchor.style.filled;\r\n    item.stroked = !config.anchor.style.filled;\r\n    if (!config.anchor.style.filled) {\r\n      item.strokeWidth = config.anchor.style.width;\r\n      item.strokeColor = realColor;\r\n    } else {\r\n      item.fillColor = realColor;\r\n    }\r\n  } else {\r\n    item.filled = false;\r\n    item.stroked = true;\r\n    item.strokeWidth = config.anchor.style.width;\r\n    item.strokeColor = realColor;\r\n  }\r\n};\r\n\r\nexport const replaceAppearance = (config: Config, item: any) => {\r\n  item.filled = false;\r\n  item.stroked = true;\r\n  item.strokeWidth = config.outline.style.width;\r\n  item.strokeColor = generateColor(config.outline.style.color as ColorPackage);\r\n};\r\n\r\n// Rearrange results per layer so anchor Groups are directly above their target path\r\nexport const sortLayerContents = () => {\r\n  for (let i = 0; i < app.activeDocument.layers.length; i++) {\r\n    let layer = app.activeDocument.layers[i];\r\n    if (layer.locked) continue;\r\n    for (let c = 0; c < layer.pathItems.length; c++)\r\n      layer.pathItems[c].zOrder(ZOrderMethod.BRINGTOFRONT);\r\n    let offset = layer.pathItems.length + 1;\r\n    for (let c = 0; c < layer.groupItems.length; c++) {\r\n      let group = layer.groupItems[c];\r\n      offset = Number(offset) - Number(1);\r\n      for (let z = 0; z < offset; z++) group.zOrder(ZOrderMethod.BRINGFORWARD);\r\n    }\r\n  }\r\n};\r\n\r\n// Generates a unique identifier for layer to use in children nodes\r\nexport const rollName = (\r\n  config: Config,\r\n  name: string,\r\n  item: any,\r\n  layer: any\r\n): string => {\r\n  let siblingCount = 0;\r\n  let nameRX = new RegExp(name + \"\\\\[\\\\d\\\\].*\");\r\n  if (!config.options.generateIds)\r\n    for (let i = 0; i < layer.pathItems.length; i++)\r\n      if (\r\n        nameRX.test(layer.pathItems[i].name) &&\r\n        layer.pathItems[i] !== item &&\r\n        !/group/i.test(layer.pathItems[i].typename)\r\n      )\r\n        siblingCount++;\r\n  return config.options.generateIds\r\n    ? name + \"_\" + shortId() + \"_\"\r\n    : name + \"[\" + siblingCount + \"]\";\r\n};\r\n\r\n// Reconstruct all PathItems with basic data to override any complex appearances\r\nexport const cloneAllPathItems = (config: Config) => {\r\n  let list = [];\r\n  let cloneProps = [\"position\", \"left\", \"top\", \"name\", \"closed\", \"layer\"];\r\n  let pathProps = [\"anchor\", \"leftDirection\", \"rightDirection\", \"pointType\"];\r\n  for (let i = app.activeDocument.pathItems.length - 1; i >= 0; i--) {\r\n    let item = app.activeDocument.pathItems[i];\r\n    const isHidden = getAncestryChain(item, \"visible\", true, [\r\n      item.hidden,\r\n      // @ts-ignore\r\n    ]).some((i) => !!i);\r\n    const isLocked = getAncestryChain(item, \"locked\", false, [\r\n      item.locked,\r\n      // @ts-ignore\r\n    ]).some((i) => !!i);\r\n    if (isHidden || isLocked) continue;\r\n    let clone = {\r\n      pathPoints: [],\r\n    };\r\n    for (let v = 0; v < cloneProps.length; v++) {\r\n      let prop = cloneProps[v];\r\n      // @ts-ignore\r\n      clone[prop] = item[prop];\r\n    }\r\n\r\n    for (let v = 0; v < item.pathPoints.length; v++)\r\n      // @ts-ignore\r\n      clone.pathPoints.push(item.pathPoints[v]);\r\n    list.push(clone);\r\n    item.remove();\r\n  }\r\n  list = filteredList(config, list);\r\n  let dupes = [];\r\n  for (let i = 0; i < list.length; i++) {\r\n    let schema = list[i];\r\n    let item = app.activeDocument.pathItems.add();\r\n    for (let v = 0; v < cloneProps.length; v++) {\r\n      let prop = cloneProps[v];\r\n      // @ts-ignore\r\n      if (prop !== \"layer\") item[prop] = schema[prop];\r\n    }\r\n    // @ts-ignore\r\n    item.move(schema.layer, ElementPlacement.PLACEATBEGINNING);\r\n    for (let v = 0; v < schema.pathPoints.length; v++) {\r\n      let point = schema.pathPoints[v];\r\n      let newpoint = item.pathPoints.add();\r\n      for (let c = 0; c < pathProps.length; c++) {\r\n        let prop = pathProps[c];\r\n        // @ts-ignore\r\n        newpoint[prop] = point[prop];\r\n      }\r\n    }\r\n    dupes.push(item);\r\n  }\r\n  return dupes;\r\n};\r\n\r\nexport const mergeClippingPaths = () => {\r\n  app.selection = null;\r\n  app.executeMenuCommand(\"Clipping Masks menu item\");\r\n  let masks = app.selection;\r\n  if (app.selection.length < 1) return null;\r\n  for (let i = 0; i < masks.length; i++) {\r\n    let mask = masks[i];\r\n    let parent = mask.parent;\r\n    let siblings = [];\r\n    for (let v = 0; v < parent.pathItems.length; v++) {\r\n      let child = parent.pathItems[v];\r\n      if (!child.clipping) {\r\n        // let tag = child.tags.add();\r\n        // tag.name = \"marked\";\r\n        siblings.push(child);\r\n      }\r\n    }\r\n    if (siblings.length > 1)\r\n      for (let v = 1; v < siblings.length; v++) {\r\n        app.selection = null;\r\n        let dupe = mask.duplicate();\r\n        let sibling = siblings[v];\r\n        let lastname = sibling.name;\r\n        dupe.selected = true;\r\n        sibling.selected = true;\r\n        intersectAction();\r\n        //\r\n        // TODO\r\n        // If path has name, doing intersect creates a new path and this reference is lost.\r\n        //\r\n      }\r\n    app.selection = null;\r\n    mask.selected = true;\r\n    siblings[0].selected = true;\r\n    let lastname = siblings[0].name;\r\n    intersectAction();\r\n    app.selection = null;\r\n    //\r\n    // Fix name transfer\r\n    //\r\n    parent.selected = true;\r\n    app.executeMenuCommand(\"ungroup\");\r\n    app.selection = null;\r\n  }\r\n};\r\n\r\n// Thanks Qwertyfly\r\n// https://community.adobe.com/t5/illustrator/js-cs6-executemenucommand/m-p/5904772#M19673\r\nexport const intersectAction = (): void => {\r\n  if (app.documents.length == 0) {\r\n    return;\r\n  }\r\n  let ActionString =\r\n    \"/version 3 /name [ 10 4578706f727454657374 ] /isOpen 1 /actionCount 1 /action-1 { /name [ 9 496e74657273656374 ] /keyIndex 0 /colorIndex 0 /isOpen 1 /eventCount 1 /event-1 { /useRulersIn1stQuadrant 0 /internalName (ai_plugin_pathfinder) /localizedName [ 10 5061746866696e646572 ] /isOpen 0 /isOn 1 /hasDialog 0 /parameterCount 1 /parameter-1 { /key 1851878757 /showInPalette -1 /type (enumerated) /name [ 9 496e74657273656374 ] /value 1 } } }\";\r\n  createAction(ActionString);\r\n  app.doScript(\"Intersect\", \"ExportTest\", false);\r\n  app.unloadAction(\"ExportTest\", \"\");\r\n};\r\nexport const createAction = (str: string): void => {\r\n  let f = new File(\"~/ScriptAction.aia\");\r\n  f.open(\"w\");\r\n  f.write(str);\r\n  f.close();\r\n  app.loadAction(f);\r\n  f.remove();\r\n};\r\n\r\nexport const randomInt = (min: number, max: number): number => {\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n};\r\n\r\nexport const shortId = (): string => {\r\n  let str = \"\";\r\n  let codex = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\n  for (let i = 0; i <= 2; i++)\r\n    str += codex.charAt(randomInt(0, codex.length - 1));\r\n  return str.toUpperCase();\r\n};\r\n","// @include './lib/json2.js'\n\nimport { ns } from \"../shared/shared\";\n\nimport * as ilst from \"./ilst/ilst\";\n\nlet main: any;\n\nswitch (BridgeTalk.appName) {\n  case \"illustrator\":\n  case \"illustratorbeta\":\n    main = ilst;\n    break;\n}\n//@ts-ignore\nconst host = typeof $ !== \"undefined\" ? $ : window;\nhost[ns] = main;\n\nexport type Scripts = typeof ilst\n"],"names":["version","id","displayName","symlink","port","servePort","startingDebugPort","extensionManifestVersion","requiredRuntimeVersion","hosts","name","type","iconDarkNormal","iconNormal","iconDarkNormalRollOver","iconNormalRollOver","parameters","width","height","panels","mainPath","panelDisplayName","autoVisible","minWidth","minHeight","maxWidth","maxHeight","startOnEvents","build","jsxBin","sourceMap","zxp","country","province","org","password","tsa","copyAssets","copyZipAssets","confirmationWindow","textGroup","multiline","confirmationText2","buttonGroup","temp","Array","values","initial","deep","red","green","blue","cyan","magenta","yellow","black","convertListToOutlines","sortLayerContents","overrideActiveLayerIfLocked","paths","count","layerCount","colorModel","chain","item","rollName","replaceAppearance","parentgroup","drawAnchor","drawHandle","stick","pathPoints","clone","list","newpoint","dupes","app","siblings","intersectAction","f","main","host"],"mappings":";;AAGA;AACEA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAAUC;AAAcV;AAAsB;AAC9CW;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAEIC;AACAV;AACAW;AACAC;AACAL;AACAC;AACAK;AACAC;AACAC;AACAC;AACF;AAEEN;AACAV;AACAY;AACAX;AACAM;AACAC;AACAM;AACAD;AACAG;AACAD;AACAE;AACF;AAEFC;AACEC;AACAC;;AAEFC;AACEC;AACAC;AACAC;AACAC;AACAC;AACAN;AACAD;;;AAGFQ;AACAC;AACF;;AChEA;;AC0BA;AACE;AACA;AACA;AACF;;AAEA;AACA;AACA;AACE;;;AAGE;;AAEAC;AACAA;;AAEA;AACAA;;;;AAIE7B;AACF;AACA8B;;AAEAA;;;;AAIE9B;AACA+B;AACF;;AAEA;AACAC;AACAA;AACAA;;AAEEhC;AACF;;AAEAiC;;;AAGAA;;AAEEjC;AACF;;;;AAIEA;AACF;;;AAGA;;AAEA;AACF;AACF;AAEA;AACE;AACAkC;AACAA;AACAA;AACA;AACF;AACA;AACE;AACAA;AACAA;AACAA;AACAA;AACA;AACF;AACA,oFAAA,SAAA;AACA;AACA,KAAA,SAAA;AACE;AACAC,EAAAA,SAAAA;;;AAGF;AACA;AACAA;;AAEE;AAEA;AACF;AACA;AACAA;;AAEE;AAEA;AACF;AACA;AACAA;;AAEE;AACAC;AACEC;AACF;AACA;AACF;AACA;AACAF;;AAEA;AACA;AACAA;;AAEE;AACA;AACF;AACA;AACAA;AACE;AACA;AACE;AACA;AACE;AACA,QAAA,SAAA;AAEF;AACF;AACA;;AAEF;;AAEA;AACAA;AACE;AAEA;AACF;;AAEA;AACA;;;AAGIG;AACF;;AAEA;AACA;;;AAGI;;AAEJ;AACA;AACF;AAEA;;;;AAME;AAGQC;AACAC;AACAC;AACF;AAEEC;AACAC;AACAC;AACAC;;AAER;AACA;AACA;AACA;AACA;AACE;AACA;AACA;;AAEJ;AAEA;AAEE;AACA;AACA;;;AAGA;AAIE;AACAC;AACAC;AACF;;AAEA;AACF;AAEA;;AAEI;;;;;AAGF;;;;AAIA;AACF;AAEA;AACEC;AACA;AACEC;AACEC;AACA;;AAEE;;AACO;AAAwB;;AACY;;AAE/CC;AACAC;AAGApD;AACA;;;AAGF;AACF;AAEA;AACE;AACF;AAEA;AAEE;;AAEE;;AAEF;;AAEA;AACF;AAEA;AACE;AACA;;AAKQ;;;AACgB;;AAIhB;;;AACgB;;AAGxB;AACF;AAEA;AAME;;AAEE;AACA;;AAEE;AACAqD;;;AAKN;AAEA;AAIE;AACA;AACF;AAEA;AACE;AACE;AAIA;AACAC;AACI;AACAC;AAEJ;AACEC;AACA;AAGA;AACE;AACEC;AACA;;AAEF;AACF;;AAGI;;AAEA;AACI;AACAA;AAEJ;;AAEAC;AACAC;AACAA;AACAL;AACF;AACJ;AACF;AACF;AAEA;AAOE;;;;AASE;;;;AAIJ;AAEA;;;AAiBIM;;AAKE;;;;AAOF;AAEA;;AASE;;;;;;AASF;AACF;AACF;AAEA;;;;;;;;AAeI;;AAEA;AACF;;;;;AAKA;AACF;AAEA;;;;AAIEN;AACF;;AAEA;AACA;AACE;;;AAGE;;AAGA;AACE;;AAEA;AACF;AACF;AACF;;AAEA;AACA;;;AAQE;;AAWF;;AAEA;AACA;;AAEE;;AAEA;;AAEE;AAEE;AAAA;;;AAEF;AAEE;AAAA;;;;AAGF;AACEO;;AAEF;AACE;AACA;AACAC;AACF;AAEA;AACE;;AAEFC;;AAEF;AACAA;;AAEA;AACE;;AAEA;AACE;AACA;AACA;AACF;AACA;;AAEA;AACE;;AAEA;AACE;AACA;AACAC;AACF;AACF;AACAC;AACF;AACA;AACF;AAEA;;AAEEC;AACA;;AAEA;AACE;AACA;;AAEA;AACE;AACA;AACE;AACA;AACAC;AACF;AACF;;;AAII;AACA;AACA;;;AAGAC;AACA;AACA;AACA;AACA;AACF;;;;AAGFD;AACA;AACAC;;AAEA;AACA;AACA;;AAEAF;;AAEF;AACF;;AAEA;AACA;AACA;AACE;AACE;AACF;;;;AAKAA;AACF;AACA;AACE;AACAG;AACAA;;AAEAH;;AAEF;AAEA;AACE;AACF;AAEA;;;AAGE;AAEA;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpoBA;AAEA;AACE;AACA;AACEI;AACA;AACJ;AACA;AACA;AACAC"}